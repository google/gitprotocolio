// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package gitprotocolio

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
	"strings"
)

type infoRefsResponseState int

const (
	infoRefsResponseStateScanServiceHeader infoRefsResponseState = iota
	infoRefsResponseStateScanServiceHeaderFlush
	infoRefsResponseStateScanOptionalProtocolVersion
	infoRefsResponseStateScanCapabilities
	infoRefsResponseStateScanRefs
	infoRefsResponseStateScanProtocolV2Capabilities
	infoRefsResponseStateEnd
)

// InfoRefsResponseChunk is a chunk of an /info/refs response.
type InfoRefsResponseChunk struct {
	ServiceHeader      string
	ServiceHeaderFlush bool
	ProtocolVersion    uint64
	Capabilities       []string
	ObjectID           string
	Ref                string
	EndOfRequest       bool
}

// EncodeToPktLine serializes the chunk.
func (c *InfoRefsResponseChunk) EncodeToPktLine() []byte {
	if c.ServiceHeader != "" {
		return BytesPacket([]byte(fmt.Sprintf("# service=%s\n", c.ServiceHeader))).EncodeToPktLine()
	}
	if c.ServiceHeaderFlush {
		return FlushPacket{}.EncodeToPktLine()
	}
	if c.ProtocolVersion != 0 {
		return BytesPacket([]byte(fmt.Sprintf("version %d\n", c.ProtocolVersion))).EncodeToPktLine()
	}
	if len(c.Capabilities) > 0 && c.ObjectID != "" && c.Ref != "" {
		// V1 packet.
		return BytesPacket([]byte(fmt.Sprintf("%s %s\000%s\n", c.ObjectID, c.Ref, strings.Join(c.Capabilities, " ")))).EncodeToPktLine()
	}
	if len(c.Capabilities) == 1 {
		// V2 packet.
		return BytesPacket([]byte(c.Capabilities[0] + "\n")).EncodeToPktLine()
	}
	if c.ObjectID != "" && c.Ref != "" {
		return BytesPacket([]byte(fmt.Sprintf("%s %s\n", c.ObjectID, c.Ref))).EncodeToPktLine()
	}
	if c.EndOfRequest {
		return FlushPacket{}.EncodeToPktLine()
	}
	panic("impossible chunk")
}

// InfoRefsResponse provides an interface for reading an /info/refs response.
// The usage is same as bufio.Scanner.
type InfoRefsResponse struct {
	scanner *PacketScanner
	state   infoRefsResponseState
	err     error
	curr    *InfoRefsResponseChunk
}

// NewInfoRefsResponse returns a new InfoRefsResponse to read from rd.
func NewInfoRefsResponse(rd io.Reader) (r *InfoRefsResponse) {
	return &InfoRefsResponse{scanner: NewPacketScanner(rd)}
}

// Err returns the first non-EOF error that was encountered by the
// InfoRefsResponse.
func (r *InfoRefsResponse) Err() error {
	return r.err
}

// Chunk returns the most recent response chunk generated by a call to Scan.
func (r *InfoRefsResponse) Chunk() *InfoRefsResponseChunk {
	return r.curr
}

// Scan advances the scanner to the next chunk. It returns false when the scan
// stops, either by reaching the end of the input or an error. After Scan
// returns false, the Err method will return any error that occurred during
// scanning, except that if it was io.EOF, Err will return nil.
func (r *InfoRefsResponse) Scan() bool {
	if r.err != nil || r.state == infoRefsResponseStateEnd {
		return false
	}
	if !r.scanner.Scan() {
		r.err = r.scanner.Err()
		return false
	}
	pkt := r.scanner.Packet()

transition:
	switch r.state {
	case infoRefsResponseStateScanServiceHeader:
		bp, ok := pkt.(BytesPacket)
		if !ok {
			r.err = SyntaxError(fmt.Sprintf("unexpected packet: %#v", pkt))
			return false
		}
		if bytes.HasPrefix(bp, []byte("version ")) {
			r.state = infoRefsResponseStateScanOptionalProtocolVersion
			goto transition
		}
		if !bytes.HasPrefix(bp, []byte("# service=")) {
			r.err = SyntaxError(fmt.Sprintf("expect the service header, but got: %v", pkt))
		}
		r.state = infoRefsResponseStateScanServiceHeaderFlush
		r.curr = &InfoRefsResponseChunk{
			ServiceHeader: strings.TrimPrefix(strings.TrimSuffix(string(bp), "\n"), "# service="),
		}
		return true
	case infoRefsResponseStateScanServiceHeaderFlush:
		if _, ok := pkt.(FlushPacket); !ok {
			r.err = SyntaxError(fmt.Sprintf("unexpected packet: %#v", pkt))
			return false
		}
		r.state = infoRefsResponseStateScanOptionalProtocolVersion
		r.curr = &InfoRefsResponseChunk{
			ServiceHeaderFlush: true,
		}
		return true
	case infoRefsResponseStateScanOptionalProtocolVersion:
		bp, ok := pkt.(BytesPacket)
		if !ok || !bytes.HasPrefix(bp, []byte("version ")) {
			r.state = infoRefsResponseStateScanCapabilities
			goto transition
		}
		verStr := strings.TrimSuffix(strings.TrimPrefix(string(bp), "version "), "\n")
		ver, err := strconv.ParseUint(verStr, 10, 64)
		if err != nil {
			r.err = SyntaxError("cannot parse the protocol version: " + verStr)
			return false
		}
		if ver == 2 {
			r.state = infoRefsResponseStateScanProtocolV2Capabilities
		} else {
			r.state = infoRefsResponseStateScanRefs
		}
		r.curr = &InfoRefsResponseChunk{
			ProtocolVersion: ver,
		}
		return true
	case infoRefsResponseStateScanCapabilities:
		switch p := pkt.(type) {
		case FlushPacket:
			r.state = infoRefsResponseStateEnd
			r.curr = &InfoRefsResponseChunk{
				EndOfRequest: true,
			}
			return true
		case BytesPacket:
			zss := bytes.SplitN(p, []byte{0}, 2)
			if len(zss) != 2 {
				r.err = SyntaxError("cannot split into two: " + string(p))
				return false
			}
			caps := []string{}
			if capStr := strings.TrimSuffix(string(zss[1]), "\n"); capStr != "" {
				// This is to avoid strings.Split("", " ") => []string{""}.
				caps = strings.Split(capStr, " ")
			}
			ss := strings.SplitN(string(zss[0]), " ", 2)
			if len(ss) != 2 {
				r.err = SyntaxError("cannot split into two: " + string(zss[0]))
				return false
			}
			r.state = infoRefsResponseStateScanRefs
			r.curr = &InfoRefsResponseChunk{
				Capabilities: caps,
				ObjectID:     ss[0],
				Ref:          ss[1],
			}
			return true
		default:
			r.err = SyntaxError(fmt.Sprintf("unexpected packet: %#v", p))
			return false
		}
	case infoRefsResponseStateScanRefs:
		switch p := pkt.(type) {
		case FlushPacket:
			r.state = infoRefsResponseStateEnd
			r.curr = &InfoRefsResponseChunk{
				EndOfRequest: true,
			}
			return true
		case BytesPacket:
			ss := strings.SplitN(strings.TrimSuffix(string(p), "\n"), " ", 2)
			if len(ss) != 2 {
				r.err = SyntaxError("cannot split into two: " + string(p))
				return false
			}
			r.curr = &InfoRefsResponseChunk{
				ObjectID: ss[0],
				Ref:      strings.TrimSuffix(ss[1], "\n"),
			}
			return true
		default:
			r.err = SyntaxError(fmt.Sprintf("unexpected packet: %#v", p))
			return false
		}
	case infoRefsResponseStateScanProtocolV2Capabilities:
		switch p := pkt.(type) {
		case FlushPacket:
			r.state = infoRefsResponseStateEnd
			r.curr = &InfoRefsResponseChunk{
				EndOfRequest: true,
			}
			return true
		case BytesPacket:
			r.curr = &InfoRefsResponseChunk{
				Capabilities: []string{strings.TrimSuffix(string(p), "\n")},
			}
			return true
		default:
			r.err = SyntaxError(fmt.Sprintf("unexpected packet: %#v", p))
			return false
		}
	}
	panic("impossible state")
}
